## ğŸŒ 1. Brute Force â€” **O(nÂ³)**

### ğŸ§  Idea:

Try every possible subarray `[i..j]`, calculate the sum, and check if it equals `0`.

### ğŸ” Steps:

* Loop over all possible starting indices `i`
* Loop over all possible ending indices `j â‰¥ i`
* For each subarray, calculate the sum in a third loop
* If the sum is 0, update `maxLen`

```cpp
// ğŸ”ğŸŒ Brute Force O(n^3) Solution: Try every subarray and check if the sum is 0
class NaiveN3 {
  public:
    int maxLen(vector<int>& arr) {
        int n = arr.size();
        int maxLen = 0;

        // ğŸ”„ Iterate over all subarrays
        for(int i = 0; i < n; i++) {
            for(int j = i; j < n; j++) {
                int sum = 0;

                // â• Calculate sum of subarray [i..j]
                for(int k = i; k <= j; k++) {
                    sum += arr[k];
                }

                // âœ… If sum == 0, update maxLen
                if(sum == 0) {
                    maxLen = max(maxLen, j - i + 1);
                }
            }
        }
        return maxLen;
    }
};
```

### âŒ Why it's inefficient:

* For array of size 1000 â†’ \~1 billion iterations (slow for large `n`)

---

### ğŸ’¡ Dry Run:

```cpp
arr = [1, -1, 3, -3]
Subarrays:
[1] â†’ 1 âŒ
[1, -1] â†’ 0 âœ… â†’ maxLen = 2
[1, -1, 3] â†’ 3 âŒ
[-1, 3] â†’ 2 âŒ
[-1, 3, -3] â†’ -1 âŒ
[3, -3] â†’ 0 âœ… â†’ maxLen = 2 (no change)
```

---

## ğŸ¢ 2. Better â€” **O(nÂ²)**

### ğŸ§  Idea:

Avoid recalculating sums from scratch.

* Fix a starting index `i`
* Use a running sum to check subarrays `[i..j]`

### âœ… Benefit:

* No third loop, so **faster than brute force**

```cpp
// ğŸ”ğŸŒ Brute Force O(n^3) Solution: Try every subarray and check if the sum is 0
class NaiveN3 {
  public:
    int maxLen(vector<int>& arr) {
        int n = arr.size();
        int maxLen = 0;

        // ğŸ”„ Iterate over all subarrays
        for(int i = 0; i < n; i++) {
            for(int j = i; j < n; j++) {
                int sum = 0;

                // â• Calculate sum of subarray [i..j]
                for(int k = i; k <= j; k++) {
                    sum += arr[k];
                }

                // âœ… If sum == 0, update maxLen
                if(sum == 0) {
                    maxLen = max(maxLen, j - i + 1);
                }
            }
        }
        return maxLen;
    }
};

```

### ğŸ›‘ Still slow:

* For large arrays (like n = 10âµ), still takes too long

---

## ğŸš€ 3. Optimal â€” **O(n)** using HashMap + Prefix Sum

### ğŸ§  Core Concept: **Prefix Sum**

* `prefix[i] = sum(arr[0] to arr[i])`
* If `prefix[i] == prefix[j]`, then subarray `(j+1 to i)` has sum 0!

Why? Because:

```
Sum(i to j) = prefix[j] - prefix[i - 1]
If prefix[i] == prefix[j], then sum between them is 0.
```

### ğŸ§® How the algorithm works:

1. Traverse array once
2. Maintain running prefix sum `sum`
3. Use a hashmap to store the **first index** at which a particular prefix sum occurs
4. If we see the same sum again, we know the subarray in between sums to zero

---

### âœ… Key Conditions:

* If `sum == 0`: The subarray from 0 to i is zero-sum â†’ `length = i + 1`
* If `sum` was seen before: we found a zero-sum subarray â†’ update length
* If `sum` never seen: store its index

---

```cpp
// ğŸš€ Optimal O(n) Solution using HashMap (Prefix Sum + First Occurrence)
class Solution {
  public:
    int maxLen(vector<int>& arr) {
        // ğŸ“Œ HashMap to store first occurrence index of prefix sums
        map<int, int> prefix_sum_idx;

        int sum = 0;       // â• Prefix sum
        int longest = 0;   // ğŸ“ Length of longest subarray with sum 0

        // ğŸ”„ Traverse array
        for(int i = 0; i < arr.size(); i++) {
            sum += arr[i];  // â• Add current element to prefix sum

            // ğŸŸ¢ Case 1: Whole subarray [0..i] has zero sum
            if(sum == 0) {
                longest = max(longest, i + 1);
            }
            // ğŸŸ¡ Case 2: Prefix sum seen before
            else if(prefix_sum_idx.find(sum) != prefix_sum_idx.end()) {
                // ğŸ“ Length = i - first_index
                longest = max(longest, i - prefix_sum_idx[sum]);
            }
            // ğŸ”´ Case 3: First time this prefix sum seen
            else {
                prefix_sum_idx[sum] = i;
            }
        }

        return longest; // ğŸ¯ Return max length found
    }
};

```

### ğŸ” Dry Run:

```cpp
arr = {15, -2, 2, -8, 1, 7, 10, 23}

Prefix Sum Progress:
Index | Value | Prefix Sum | HashMap            | Max Length
------------------------------------------------------------
0     | 15    | 15         | {15: 0}            | 0
1     | -2    | 13         | {15: 0, 13: 1}     | 0
2     | 2     | 15         | 15 seen at 0       | maxLen = 2 (2 - 0)
3     | -8    | 7          | {.., 7: 3}         | 2
4     | 1     | 8          | {.., 8: 4}         | 2
5     | 7     | 15         | 15 seen at 0       | maxLen = 5 (5 - 0)
6     | 10    | 25         | {.., 25: 6}        | 5
7     | 23    | 48         | {.., 48: 7}        | 5

âœ” Longest zero-sum subarray: `{ -2, 2, -8, 1, 7 }` â†’ Length = **5**
```

---

## ğŸ“¦ Summary

| Approach        | Time Complexity | Space Complexity | Scalable? |
| --------------- | --------------- | ---------------- | --------- |
| Brute Force     | O(nÂ³)           | O(1)             | âŒ         |
| Prefix Sum Loop | O(nÂ²)           | O(1)             | âŒ         |
| HashMap (Best)  | O(n)            | O(n)             | âœ…         |

---


